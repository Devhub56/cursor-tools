import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import { exec as execCallback } from 'child_process';
import os from 'os';
import type { Command, CommandGenerator, CommandOptions, Provider } from '../types';
import { loadEnv, loadConfig } from '../config';
import { createProvider } from '../providers/base';
import { yieldOutput } from '../utils/output';
import { saveToFile } from '../utils/output';
import { 
  TestError, 
  FeatureFileParseError, 
  TestExecutionError, 
  TestTimeoutError 
} from '../errors';
import { glob } from 'glob';
import { resolveAssetsInDescription, AssetReference, AssetType } from '../utils/assets';

const exec = promisify(execCallback);
const readFile = promisify(fs.readFile);
const mkdir = promisify(fs.mkdir);

/**
 * Extended command options for the test command
 */
interface TestOptions extends CommandOptions {
  output?: string;
  parallel?: number;
  branch?: string;
  compareWith?: string;
  timeout?: number;
  retries?: number;
  tag?: string;
}

/**
 * Represents a test scenario in a feature behavior file
 */
interface TestScenario {
  id: string;
  type: string;
  description: string;
  taskDescription: string;
  expectedBehavior: string[];
  successCriteria: string[];
  tags?: string[];
  assets?: Record<string, AssetReference>;
}

/**
 * Represents the parsed content of a feature behavior file
 */
interface FeatureBehavior {
  name: string;
  description: string;
  scenarios: TestScenario[];
}

/**
 * Represents the result of executing a test scenario
 */
interface TestScenarioResult {
  id: string;
  type: string;
  description: string;
  taskDescription: string;
  approachTaken: string;
  commands: string[];
  output: string;
  expectedBehavior: {
    behavior: string;
    met: boolean;
  }[];
  successCriteria: {
    criteria: string;
    met: boolean;
  }[];
  result: 'PASS' | 'FAIL';
  executionTime: number;
  error?: string;
}

/**
 * Represents a complete test report for a feature behavior file
 */
interface TestReport {
  featureName: string;
  description: string;
  scenarios: TestScenarioResult[];
  timestamp: string;
  branch: string;
  provider: string;
  model: string;
  os: string;
  nodeVersion: string;
  overallResult: 'PASS' | 'FAIL';
  failedScenarios: string[];
  totalExecutionTime: number;
}

/**
 * Exponential backoff retry configuration
 */
interface RetryConfig {
  initialDelay: number;
  maxDelay: number;
  factor: number;
  retries: number;
  jitter: boolean;
}

/**
 * Implementation of the test command
 */
export class TestCommand implements Command {
  private config;

  constructor() {
    // Load environment variables and configuration
    loadEnv();
    this.config = loadConfig();
  }

  /**
   * Execute the test command
   * 
   * @param query - The feature behavior file or pattern to test
   * @param options - Command options
   */
  async *execute(query: string, options: TestOptions): CommandGenerator {
    try {
      // Check if query is a glob pattern
      if (query.includes('*')) {
        yield* this.executeAll(query, options);
        return;
      }

      // Set default options
      const outputDir = options.output || 'tests/reports';
      const parallel = options.parallel || Math.max(1, os.cpus().length - 1);
      const branch = options.branch || await getCurrentBranch();
      const provider = options.provider || 'anthropic';
      const model = options.model || 'claude-3-7-sonnet-latest';
      const timeout = options.timeout || 300; // 5 minutes
      const retries = options.retries || 3;
      const debug = options.debug || false;
      const tags = options.tag ? options.tag.split(',') : undefined;

      await yieldOutput(`\nüß™ Testing feature behavior: ${query}\n`);
      await yieldOutput(`üìã Options: outputDir=${outputDir}, parallel=${parallel}, branch=${branch}, provider=${provider}, model=${model}, timeout=${timeout}s, retries=${retries}${tags ? `, tags=${tags.join(',')}` : ''}\n\n`);

      // Create output directory if it doesn't exist
      const branchOutputDir = path.join(outputDir, branch);
      await createDirIfNotExists(branchOutputDir);

      // Parse the feature behavior file
      const featureBehavior = await parseFeatureBehaviorFile(query);
      if (!featureBehavior) {
        throw new FeatureFileParseError(query);
      }

      await yieldOutput(`üîç Testing feature: ${featureBehavior.name}\n`);
      await yieldOutput(`üìù Description: ${featureBehavior.description}\n`);

      // Filter scenarios by tags if provided
      let scenarios = featureBehavior.scenarios;
      if (tags && tags.length > 0) {
        scenarios = scenarios.filter(scenario => {
          if (!scenario.tags) return false;
          return tags.some(tag => scenario.tags!.includes(tag));
        });
        await yieldOutput(`üè∑Ô∏è Filtered to ${scenarios.length} scenarios with tags: ${tags.join(', ')}\n\n`);
      } else {
        await yieldOutput(`üß© Total scenarios: ${scenarios.length}\n\n`);
      }

      if (scenarios.length === 0) {
        await yieldOutput(`‚ö†Ô∏è No scenarios match the specified criteria.\n`);
        return;
      }

      // Set up retry configuration
      const retryConfig: RetryConfig = {
        initialDelay: 1000, // 1 second
        maxDelay: 30000, // 30 seconds
        factor: 2, // Exponential factor
        retries,
        jitter: true, // Add some randomness to prevent thundering herd
      };

      // Execute scenarios in parallel
      const startTime = Date.now();
      const results: TestScenarioResult[] = await executeScenarios(
        scenarios,
        {
          provider: provider as Provider,
          model,
          timeout,
          retryConfig,
          debug,
          parallel,
        }
      );

      // Calculate overall result
      const failedScenarios = results
        .filter(r => r.result === 'FAIL')
        .map(r => r.id);
      
      const overallResult = failedScenarios.length === 0 ? 'PASS' : 'FAIL';
      const totalExecutionTime = (Date.now() - startTime) / 1000; // in seconds

      // Build test report
      const testReport: TestReport = {
        featureName: featureBehavior.name,
        description: featureBehavior.description,
        scenarios: results,
        timestamp: new Date().toISOString(),
        branch,
        provider,
        model,
        os: `${os.platform()} ${os.release()}`,
        nodeVersion: process.version,
        overallResult,
        failedScenarios,
        totalExecutionTime,
      };

      // Save test report
      const reportFilename = getReportFilename(query, branch);
      const reportPath = path.join(branchOutputDir, reportFilename);
      await saveReportToFile(reportPath, testReport);

      // Save result file (PASS/FAIL)
      const resultFilename = getResultFilename(query, branch);
      const resultPath = path.join(branchOutputDir, resultFilename);
      await saveResultToFile(resultPath, overallResult);

      // Compare with previous report if requested
      if (options.compareWith) {
        await yieldOutput(`\nüìä Comparing with previous report: ${options.compareWith}\n`);
        await compareReports(reportPath, options.compareWith);
      }

      // Output summary
      await yieldOutput(`\n${overallResult === 'PASS' ? '‚úÖ' : '‚ùå'} Test completed: ${overallResult}\n`);
      await yieldOutput(`üìä Report saved to: ${reportPath}\n`);
      await yieldOutput(`üèÅ Result saved to: ${resultPath}\n`);
      await yieldOutput(`‚è±Ô∏è Total execution time: ${totalExecutionTime.toFixed(2)} seconds\n`);
      
      if (failedScenarios.length > 0) {
        await yieldOutput(`\n‚ö†Ô∏è Failed scenarios (${failedScenarios.length}):\n`);
        for (const id of failedScenarios) {
          await yieldOutput(`  - ${id}\n`);
        }
      }

      await yieldOutput(`\n`);
    } catch (error) {
      if (error instanceof TestError) {
        await yieldOutput(`‚ùå ${error.message}\n`);
        if (options.debug && error.details) {
          await yieldOutput(`Details: ${JSON.stringify(error.details, null, 2)}\n`);
        }
      } else if (error instanceof Error) {
        await yieldOutput(`‚ùå Error: ${error.message}\n`);
        if (options.debug && error.stack) {
          await yieldOutput(`Stack trace: ${error.stack}\n`);
        }
      } else {
        await yieldOutput(`‚ùå Unknown error occurred\n`);
      }
    }
  }

  /**
   * Execute tests for multiple feature behavior files matching a pattern
   * 
   * @param pattern - Glob pattern to match feature behavior files
   * @param options - Command options
   */
  private async *executeAll(pattern: string, options: TestOptions): CommandGenerator {
    try {
      // Find all feature behavior files matching the pattern
      const files = await findFeatureBehaviorFiles(pattern);
      
      if (files.length === 0) {
        await yieldOutput(`‚ùå No feature behavior files found matching pattern: ${pattern}\n`);
        return;
      }

      await yieldOutput(`üß™ Found ${files.length} feature behavior files to test:\n`);
      for (const file of files) {
        await yieldOutput(`  - ${file}\n`);
      }
      await yieldOutput(`\n`);

      // Execute tests for each file sequentially
      for (const file of files) {
        yield* this.execute(file, options);
      }

      await yieldOutput(`\n‚úÖ All tests completed\n`);
    } catch (error) {
      if (error instanceof Error) {
        await yieldOutput(`‚ùå Error: ${error.message}\n`);
        if (options.debug && error.stack) {
          await yieldOutput(`Stack trace: ${error.stack}\n`);
        }
      } else {
        await yieldOutput(`‚ùå Unknown error occurred\n`);
      }
    }
  }
}

/**
 * Get the current git branch
 * 
 * @returns The current branch name or 'unknown-branch' if not in a git repository
 */
async function getCurrentBranch(): Promise<string> {
  try {
    const { stdout } = await exec('git branch --show-current');
    return stdout.trim() || 'unknown-branch';
  } catch (error) {
    console.error('Error determining current branch:', error);
    return 'unknown-branch';
  }
}

/**
 * Create a directory if it doesn't exist
 * 
 * @param dir - Directory path to create
 */
async function createDirIfNotExists(dir: string): Promise<void> {
  await mkdir(dir, { recursive: true });
}

/**
 * Parse a feature behavior file into a structured object
 * 
 * @param filePath - Path to the feature behavior file
 * @returns Parsed feature behavior or null if parsing failed
 */
async function parseFeatureBehaviorFile(filePath: string): Promise<FeatureBehavior | null> {
  try {
    const content = await readFile(filePath, 'utf8');
    const lines = content.split('\n');

    let name = '';
    let description = '';
    const scenarios: TestScenario[] = [];

    let currentSection: string = '';
    let currentScenario: Partial<TestScenario> = {};
    let taskDescription = '';
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Parse feature name
      if (line.startsWith('# Feature Behavior:')) {
        name = line.substring('# Feature Behavior:'.length).trim();
      } 
      // Parse description section
      else if (line === '## Description') {
        currentSection = 'description';
      } 
      // Parse test scenarios section
      else if (line === '## Test Scenarios') {
        currentSection = 'scenarios';
      } 
      // Parse individual scenario
      else if (line.startsWith('### Scenario')) {
        // Save previous scenario if exists
        if (Object.keys(currentScenario).length > 0) {
          scenarios.push(currentScenario as TestScenario);
        }
        
        // Initialize new scenario
        currentScenario = {
          id: `Scenario ${scenarios.length + 1}`,
          description: line.substring(line.indexOf(':') + 1).trim(),
          type: line.includes('(Happy Path)') ? 'Happy Path' : 
                line.includes('(Error Handling)') ? 'Error Handling' : 
                line.includes('(Edge Case)') ? 'Edge Case' : 
                line.includes('(Performance)') ? 'Performance' : 'Other',
          taskDescription: '',
          expectedBehavior: [],
          successCriteria: [],
          tags: [],
          assets: {}
        };
        
        currentSection = 'scenario';
        taskDescription = '';
      } 
