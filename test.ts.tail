  markdown += `- **Branch:** ${branch}\n`;
  markdown += `- **Provider:** ${provider}\n`;
  markdown += `- **Model:** ${model}\n`;
  markdown += `- **Total Execution Time:** ${totalExecutionTime.toFixed(2)} seconds\n`;
  markdown += `- **Scenarios:** ${scenarios.length} total, ${scenarios.filter(s => s.result === 'PASS').length} passed, ${failedScenarios.length} failed\n\n`;
  
  // Description section
  markdown += `## Description\n\n${description}\n\n`;
  
  // Failed scenarios section (if any)
  if (failedScenarios.length > 0) {
    markdown += `## Failed Scenarios\n\n`;
    failedScenarios.forEach(id => {
      const scenario = scenarios.find(s => s.id === id);
      if (scenario) {
        markdown += `- **${scenario.id}:** ${scenario.description} - ${scenario.error || 'No error message'}\n`;
      }
    });
    markdown += `\n`;
  }
  
  // Detailed results section
  markdown += `## Detailed Results\n\n`;
  
  scenarios.forEach(scenario => {
    markdown += `### ${scenario.id}: ${scenario.description} (${scenario.type})\n\n`;
    
    markdown += `#### Task Description\n\n${scenario.taskDescription}\n\n`;
    
    markdown += `#### Approach Taken\n\n${scenario.approachTaken}\n\n`;
    
    if (scenario.commands.length > 0) {
      markdown += `#### Commands Used\n\n\`\`\`bash\n${scenario.commands.join('\n')}\n\`\`\`\n\n`;
    }
    
    markdown += `#### Output\n\n\`\`\`\n${scenario.output}\n\`\`\`\n\n`;
    
    // Expected behavior section
    markdown += `#### Expected Behavior\n\n`;
    scenario.expectedBehavior.forEach(item => {
      markdown += `- ${item.met ? '✅' : '❌'} ${item.behavior}\n`;
    });
    markdown += '\n';
    
    // Success criteria section
    markdown += `#### Success Criteria\n\n`;
    scenario.successCriteria.forEach(item => {
      markdown += `- ${item.met ? '✅' : '❌'} ${item.criteria}\n`;
    });
    markdown += '\n';
    
    // Result
    markdown += `#### Result: ${scenario.result === 'PASS' ? '✅ PASS' : '❌ FAIL'}\n\n`;
    
    // Execution time
    markdown += `#### Execution Time: ${scenario.executionTime.toFixed(2)} seconds\n\n`;
    
    markdown += '---\n\n';
  });
  
  return markdown;
}

/**
 * Save the test result to a file (PASS/FAIL)
 * 
 * @param resultPath - Path to save the result
 * @param result - The test result ('PASS' or 'FAIL')
 */
async function saveResultToFile(resultPath: string, result: string): Promise<void> {
  await saveToFile(resultPath, result, 'Test result');
}

/**
 * Compare two test reports and output the differences
 * 
 * @param currentReportPath - Path to the current report
 * @param previousReportPath - Path to the previous report
 */
async function compareReports(currentReportPath: string, previousReportPath: string): Promise<void> {
  try {
    const currentReport = JSON.parse(await readFile(currentReportPath, 'utf8'));
    const previousReport = JSON.parse(await readFile(previousReportPath, 'utf8'));
    
    // Compare and output differences
    await yieldOutput(`Comparison not implemented yet.\n`);
  } catch (error) {
    await yieldOutput(`Failed to compare reports: ${error instanceof Error ? error.message : String(error)}\n`);
  }
}

/**
 * Find all feature behavior files matching a pattern
 * 
 * @param pattern - Glob pattern to match feature behavior files
 * @returns Array of file paths
 */
async function findFeatureBehaviorFiles(pattern: string): Promise<string[]> {
  return glob(pattern);
}